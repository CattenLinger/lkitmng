#!/usr/bin/env lua

--------------------------------------------------------------------------------------------------------------------------------
-- Bootstrap
--------------------------------------------------------------------------------------------------------------------------------

---@type string @os type, unix(linux) or nt
os.type = (function()
	if package.path:find('/', 1, true) == 1 then return 'unix' else return 'nt' end
end)()

-- currenly lkitmgr only support unix/linux
if os.type ~= 'unix' then io.stderr:write("lkitmgr only support unix currenly. \n"); os.exit(1); end

-- END BOOTSTRAP


--------------------------------------------------------------------------------------------------------------------------------
string = string do -- Minimal string lib
--------------------------------------------------------------------------------------------------------------------------------

--- Just use + to concating strings. + never confusing the code, trust us.
---
---@param self string 
---@param another any
getmetatable("").__add = function(self, another) return self .. tostring(another) end

--- format string, same as string.format
function fstring(...) return string.format(...) end

string.lines = function(str)
	local s = str
	if s:sub(-1) ~= "\n" then s = s +"\n" end
    return s:gmatch("(.-)\n")
end

string.trim = function(s)
	return s:match "^%s*(.-)%s*$"
end

end -- END STRING

--------------------------------------------------------------------------------------------------------------------------------
table = table do -- Minimal Table lib
--------------------------------------------------------------------------------------------------------------------------------
local protected_table_error = function() error("protected table") end

--- dump table content to target, if no target presented, use an empty table
---@param source table @source table
---@param target? table @target table, empty raw table if not presented
---@return table
table.dump = function(source, target)
	local target = target or {}
	for k, v in pairs(source) do target[k] = v end
	return target
end

--- protect a table.
---@param tb table @target table
---@param mt? table @optional metatable template
table.protect = function(tb, mt)
	local new_mt = {}
	if mt then table.dump(mt, new_mt) end
	new_mt.__newindex = protected_table_error
	if not new_mt.__metatable then new_mt.__metatable = false end
	return setmetatable(tb, new_mt)
end

---@type table @a protected empty table
table.empty = (function()
	local empty = {}
	return table.protect(empty, { __metatable = empty })
end)()

pack, unpack = table.pack, table.unpack

end -- END TABLE

--------------------------------------------------------------------------------------------------------------------------------
shell = {} do -- Minimal shell lib
--------------------------------------------------------------------------------------------------------------------------------

--- Execute a shell command, wait and return stdout result
---@param command string @shell command
---@return string        @result lines
---@return boolean|nil   @success or not
---@return string        @process state 
---@return integer       @exit code
shell.execute = function(command)
	local pipe, error = io.popen(command)
	if not pipe then return nil, ("Could not open pipe for command: " + command) , error end
	local lines = pipe:read("*a")
	local result, state, exit_code = pipe:close()
	return lines, result, state, exit_code
end

--- Create a shell execute template
---@param template string @shell command string template
function shell:template(template)
	return function(...)
		local command = template:format(...)
		return self.execute(command)
	end
end

shell.which = (function(cmd)
	local template = shell:template(cmd)
	return function(name)
		local result, success, state, exit_code = template(name)
		if result then return result:trim() end
		return nil, success, state, exit_code
	end
end)("which '%s' 2> /dev/null")

end -- END SHELL

--------------------------------------------------------------------------------------------------------------------------------
os = os do -- Minimal os lib
--------------------------------------------------------------------------------------------------------------------------------

--- create an executable template
---@param template string @shell command string
---@return fun(...) @a function that execute the shell command with arguments
os.executable = function(template)
	return function(...)
		return os.execute(template:format(...))
	end
end

--- require a command, throw error if no such command
---@param name string @comamnd name
---@param msg? string @optional string message
os.require_command = (function(template)
	local executable = os.executable(template)
	local default_error_template = "Require command %q"
	return function(name, msg)
		if not executable(name) then error(msg or default_error_template:format(name)); end
	end
end)("command -v '%s' 2>&1 > /dev/null")

--- get basename of a path string
---@param name string @path
---@return string @basename of this path
os.basename = (function(cmd)
	local template = shell.template(cmd)
	return function(name)
		return template(name)
	end
end)("basename $(which '%s')")

os.executable = function()
	local template = "which '%s'"
	local handle = io.popen(template:format(arg[0]))
	local name = handle:read()
	handle:close()
	return name
end

--- put content to stdout
---@param str string
function stdout(...) io.stdout:write(fstring(...)) end

--- put content to stderr
---@param str string
function stderr(...) io.stderr:write(fstring(...)) end

--- exit program, with optional message
---@param exit_code? integer @optional exit code
---@param msg? string        @optional message write to stderr
os.exit = (function(origin)
	return function(exit_code, msg)
		local exit_code = exit_code or 0
		if msg then stderr("%s\n", msg) end
		origin(exit_code)
	end
end)(os.exit)

end -- END OS

--------------------------------------------------------------------------------------------------------------------------------
fs = {} do -- Minimal FileSystem lib
--------------------------------------------------------------------------------------------------------------------------------
--- check if directory exists or is a directory
---@param path string
---@return boolean
fs.is_directory_exists = (function(cmd)
	local template = os.executable(cmd)
	return function(path)
		return template(path) or false
	end
end)("test -d %q 2>&1 > /dev/null")

--- check if file exists or is a file
---@param path string
---@return boolean
fs.is_file_exists = (function(cmd)
	local template = os.executable(cmd)
	return function(path)
		return template(path) or false
	end
end)("test -f %q 2>&1 > /dev/null")

--- Do filesystem initialization
--- This method can only be invoke once.
fs.initialization = function()
	fs.work_dir = (function ()
		local handle, success, state, exit_code = shell:execute("pwd")
		if not handle then error("Could not get current directory"); end
		return path
	end)()

	fs.initialization = nil
end

end -- END FS

--------------------------------------------------------------------------------------------------------------------------------
app = { lkitmgr = "lkitmgr" } do -- Minimal application lib
--------------------------------------------------------------------------------------------------------------------------------
app.initialization = function(args)
	app.initialization = nil
	-- handle parameters
	app.parameters = (function(args)
		local is_subcommand, mgr_arg, sub_arg = false, {}, {}
		for _, arg in ipairs(args) do
			if not is_subcommand and arg:find('-', 1, true) == 0 then is_subcommand = true; end

			if is_subcommand then table.insert(sub_arg, arg)
			else table.insert(mgr_arg, arg) end

			::continue::
		end
		return { manager = mgr_arg; subcommand = sub_arg; }
	end)(pack(unpack(args, 2)))

	fs.initialization()
	-- handle entry
	app.entry = args[0]
	app.executable = os.basename(app.entry)

	-- get path information
	local path = {}

	path.home = (function()
		local value = os.getenv("LKITMGR_HOME") or fs.work_dir
		if not fs.is_directory_exists(value) then os.exit(1, fstring("%q is not a valid LKitManager home.", value)) end
		return value
	end)()

	path.binaries  = path.home + "/bin"
	path.libraries = path.home + "/lib"

	-- add lib path to lua path
	package.path = path.libraries + "/?.lua;" + package.path

	app.path = path
end

end -- END APP

-- if is required like an lib then just return the un-initialized app
if not arg or not arg[0]
then return app
else
	local _, error = pcall(app.initialization, arg)
	if error then os.exit(1, fstring("Error: %s", error)) end
end

